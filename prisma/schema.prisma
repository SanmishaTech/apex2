generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                      Int            @id @default(autoincrement())
  name                    String?
  email                   String         @unique
  passwordHash            String // was: password
  role                    String
  profilePhoto            String?
  emailVerified           DateTime?
  verificationToken       String?        @unique
  verificationTokenExpiry DateTime?
  status                  Boolean        @default(true)
  lastLogin               DateTime?
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt
  refreshTokens           RefreshToken[]
  projectUsers            ProjectUser[]
  projectFilesUploaded    ProjectFile[]  @relation("UserProjectFiles")

  @@index([role])
}

model RefreshToken {
  id         Int       @id @default(autoincrement())
  token      String    @unique
  userId     Int
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt  DateTime
  createdAt  DateTime  @default(now())
  revokedAt  DateTime?
  replacedBy String?

  @@index([userId])
  @@index([expiresAt])
}

// Represents a project. Each project can have many client users (via ProjectClient)
model Project {
  id          Int                   @id @default(autoincrement())
  name        String
  clientName  String // Top-level client / organization name
  location    String? // Optional location string (city / region / address)
  description String?               @db.Text
  designImage String? // stored filename or URL of the project design image
  users       ProjectUser[]
  files       ProjectFile[]
  blocks      Block[]
  cracks      CrackIdentification[]
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  DesignMap   DesignMap[]

  @@index([name])
  @@index([clientName])
}

// Join table linking Users (with a global role of e.g. "CLIENT") to Projects.
// Keeping a separate join model lets you later add per-project roles or metadata.
model ProjectUser {
  id        Int     @id @default(autoincrement())
  projectId Int
  userId    Int
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([userId])
  @@index([projectId])
}

// Files (documents, spreadsheets, PDFs, etc.) attached to a Project.
// Store both an internal filename/key and the original upload name.
model ProjectFile {
  id           Int      @id @default(autoincrement())
  projectId    Int
  project      Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  uploadedById Int? // optional: which user uploaded
  uploadedBy   User?    @relation("UserProjectFiles", fields: [uploadedById], references: [id], onDelete: SetNull)
  // Storage metadata
  filename     String // internal stored filename or generated UUID name
  originalName String // original filename from user
  title        String // display title (required)
  mimeType     String // e.g. application/pdf
  size         Int // bytes
  storageKey   String? // e.g. S3 object key, if different from filename
  url          String? // cached/public URL if applicable
  createdAt    DateTime @default(now())

  @@index([projectId])
  @@index([uploadedById])
  @@index([mimeType])
}

// Physical / logical block within a project that contains crack identifications
model Block {
  id        Int                   @id @default(autoincrement())
  projectId Int
  name      String // e.g. Block A / Segment 1
  project   Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  cracks    CrackIdentification[]
  createdAt DateTime              @default(now())
  updatedAt DateTime              @updatedAt

  @@unique([projectId, name]) // block names unique within project
  @@index([projectId])
}

// Individual crack record captured under a block
model CrackIdentification {
  id            Int        @id @default(autoincrement())
  projectId     Int // duplicated for easier querying/filtering
  blockId       Int
  chainageFrom  String?
  chainageTo    String?
  rl            Float?
  lengthMm      Float?
  widthMm       Float?
  heightMm      Float?
  defectType    String?
  videoFileName String?
  // Video timeline position (HH:MM:SS). Stored as fixed-length CHAR(8) string (e.g. 03:30:00).
  startTime     String?    @db.Char(8)
  endTime       String?    @db.Char(8)
  project       Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  block         Block      @relation(fields: [blockId], references: [id], onDelete: Cascade)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  DesignMap     DesignMap?

  @@index([projectId])
  @@index([blockId])
}

model DesignMap {
  id                    Int                 @id @default(autoincrement())
  projectId             Int
  project               Project             @relation(fields: [projectId], references: [id], onDelete: Cascade)
  crackIdentificationId Int                 @unique // Each map is unique to one crack identification
  crackIdentification   CrackIdentification @relation(fields: [crackIdentificationId], references: [id], onDelete: Cascade)

  // Rectangle coordinates for the map area
  x      Float
  y      Float
  width  Float
  height Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([projectId])
}
