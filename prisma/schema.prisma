generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                       Int             @id @default(autoincrement())
  name                     String?
  email                    String          @unique
  passwordHash             String          // was: password
  role                     String
  profilePhoto             String?
  emailVerified            DateTime?
  verificationToken        String?         @unique
  verificationTokenExpiry  DateTime?
  status                   Boolean         @default(true)
  lastLogin                DateTime?
  createdAt                DateTime        @default(now())
  updatedAt                DateTime        @updatedAt
  refreshTokens            RefreshToken[]
  projectUsers             ProjectUser[]
  projectFilesUploaded     ProjectFile[]   @relation("UserProjectFiles")

  @@index([role])
}

model RefreshToken {
  id         Int       @id @default(autoincrement())
  token      String    @unique
  userId     Int
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt  DateTime
  createdAt  DateTime  @default(now())
  revokedAt  DateTime?
  replacedBy String?

  @@index([userId])
  @@index([expiresAt])
}

// Represents a project. Each project can have many client users (via ProjectClient)
model Project {
  id          Int              @id @default(autoincrement())
  name        String
  clientName  String           // Top-level client / organization name
  location    String?          // Optional location string (city / region / address)
  description String?          @db.Text
  users       ProjectUser[]
  files       ProjectFile[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([name])
  @@index([clientName])
}

// Join table linking Users (with a global role of e.g. "CLIENT") to Projects.
// Keeping a separate join model lets you later add per-project roles or metadata.
model ProjectUser {
  id         Int      @id @default(autoincrement())
  projectId  Int
  userId     Int
  project    Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([userId])
  @@index([projectId])
}

// Files (documents, spreadsheets, PDFs, etc.) attached to a Project.
// Store both an internal filename/key and the original upload name.
model ProjectFile {
  id            Int       @id @default(autoincrement())
  projectId     Int
  project       Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  uploadedById  Int?      // optional: which user uploaded
  uploadedBy    User?     @relation("UserProjectFiles", fields: [uploadedById], references: [id], onDelete: SetNull)
  // Storage metadata
  filename      String    // internal stored filename or generated UUID name
  originalName  String    // original filename from user
  title         String    // display title (required)
  mimeType      String    // e.g. application/pdf
  size          Int       // bytes
  storageKey    String?   // e.g. S3 object key, if different from filename
  url           String?   // cached/public URL if applicable
  createdAt     DateTime  @default(now())

  @@index([projectId])
  @@index([uploadedById])
  @@index([mimeType])
}
